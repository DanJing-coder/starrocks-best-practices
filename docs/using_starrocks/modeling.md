# 数据建模

数据模型是发挥 StarRocks 极致性能的基石。一个好的数据模型设计，能够极大地提升查询效率、降低存储成本，并简化数据导入和维护的复杂度。本章将深入探讨 StarRocks 的核心建模理念、四大数据模型及其适用场景，并提供一套详细的建表最佳实践。

## 1. 核心设计理念

StarRocks 的表设计主要围绕三个核心概念展开：**排序键 (Sort Key)**、**分区键 (Partition Key)** 和 **分桶键 (Bucket Key)**。

*   **排序键 (Sort Key):** 决定了数据在物理存储上的排序方式。StarRocks 会按照排序键对数据进行排序，这使得基于排序键前缀的查询能够快速定位到数据，极大地提升了查询性能。
*   **分区键 (Partition Key):** 用于将一张大表在逻辑上切分成多个更小的、易于管理的分区。通常使用时间字段作为分区键，这对于数据生命周期管理（TTL）和基于时间范围的查询优化至关重要。
*   **分桶键 (Bucket Key):** 用于将每个分区内的数据通过哈希算法，均匀地切分成多个数据分片（Tablet）。分桶键的选择直接影响数据是否均匀分布，避免数据倾斜。

## 2. 数据模型

StarRocks 提供四种数据模型，以适应不同的业务场景。

### 2.1 明细模型 (Duplicate Key Model)

*   **描述:** 不进行任何预聚合，完全保留所有原始数据行。
*   **适用场景:**
    *   需要存储和分析原始日志、事件流等明细数据。
    *   对数据进行任意维度的灵活分析（Ad-hoc 查询）。
*   **最佳实践:**
    *   **排序键选择:** 明细模型的查询性能高度依赖于排序键的设计。请务必将最常用的过滤字段放在排序键的最前面。
    *   **数据去重:** 明细模型本身不保证数据唯一性。如果业务需要去重，可以在查询时使用 `SELECT DISTINCT`，或者在上游数据处理（如 Flink, Spark）中完成去重逻辑。
    *   **分桶方式:** 如果表中没有合适的、基数非常高的列作为分桶键，或者没有基于分桶键进行 Colocate Join 的需求，推荐使用随机分桶 (`DISTRIBUTED BY RANDOM`)。这可以确保数据在所有 BE 节点上绝对均匀地分布，有效避免数据倾斜问题。
    *   **适用性:** 如果业务场景中没有明显的聚合需求，或者需要对原始数据进行多维度、不可预知的探索性分析，明细模型是最佳选择。

*   **建表示例:**
    ```sql
    CREATE TABLE user_behavior_log (
        event_time DATETIME,
        user_id BIGINT,
        event_type VARCHAR(20),
        device_id VARCHAR(50),
        channel VARCHAR(20)
    )
    DUPLICATE KEY(event_time, user_id)
    ORDER BY (event_time, user_id) -- 显式指定排序键
    PARTITION BY RANGE(event_time) ( -- 分区键
        PARTITION p202311 FROM ('2023-11-01') TO ('2023-12-01'),
        PARTITION p202312 FROM ('2023-12-01') TO ('2024-01-01')
    )
    DISTRIBUTED BY RANDOM BUCKETS 32; -- 推荐使用随机分桶
    ```

### 2.2 聚合模型 (Aggregate Key Model)

*   **描述:** 在数据导入过程中，对排序键（聚合键）相同的数据行进行预聚合。对于非排序键的指标列，可以指定不同的聚合函数（`SUM`, `MIN`, `MAX`, `REPLACE`）。
*   **适用场景:**
    *   固定维度的报表和数据看板，如网站的 PV/UV 统计。
    *   对查询性能要求极高，可以通过预聚合大幅减少查询时的数据量和计算量。
*   **建表示例:**
    ```sql
    CREATE TABLE daily_sales_stats (
        sale_date DATE,
        category_id INT,
        region VARCHAR(50),
        total_sales BIGINT SUM, -- 指标列，使用 SUM 聚合
        max_single_sale INT MAX, -- 指标列，使用 MAX 聚合
        last_updated_user VARCHAR(100) REPLACE -- 指标列，保留最新值
    )
    AGGREGATE KEY(sale_date, category_id, region) -- 聚合键
    ORDER BY (sale_date, category_id, region) -- 显式指定排序键
    PARTITION BY RANGE(sale_date) (...)
    DISTRIBUTED BY HASH(category_id) BUCKETS 16;
    ```

### 2.3 主键模型 (Primary Key Model)

*   **描述:** 保证主键的唯一性，支持基于主键的实时、按行更新和删除。其底层采用 "delete-and-insert" 机制实现，相比其他模型，在数据导入时会消耗更多 CPU 和内存资源用于 Compaction。这是 StarRocks 实现实时数仓（Real-time DWH）的核心模型。
*   **适用场景:**
    *   **CDC 数据同步:** 对接上游 MySQL, Oracle 等业务库的 Binlog，实现数据的实时同步和更新。
    *   需要频繁更新状态的订单系统、用户画像、账户余额等。
*   **建表示例:**
    ```sql
    CREATE TABLE orders (
        order_id BIGINT,
        user_id BIGINT,
        order_status INT,
        order_amount DECIMAL(10, 2),
        update_time DATETIME
    )
    PRIMARY KEY(order_id)
    PARTITION BY RANGE(update_time) (...)
    DISTRIBUTED BY HASH(order_id) BUCKETS 32;
    ```
*   **最佳实践:**
    *   **主键选择:**
        *   主键列必须是 `NOT NULL`。
        *   主键列不能是 `FLOAT` 或 `DOUBLE` 类型。
        *   主键列自动成为排序键，因此无需也无法使用 `ORDER BY` 子句。
        *   建议主键尽可能简短，以提高性能。
    *   **持久化主键索引 (v3.1+):**
        *   对于数据量巨大或内存资源有限的场景，强烈建议开启持久化主键索引。这会将主键索引从内存存放到磁盘上，**极大降低内存消耗**，但对磁盘 I/O 有一定要求，**推荐使用 SSD**。
        *   开启方式：在 `PROPERTIES` 中设置 `"enable_persistent_index" = "true"`。
    *   **部分列更新:**
        *   主键模型支持部分列更新。在导入数据时，只需提供主键和需要更新的列即可。
        *   使用 Flink-Connector 或 Stream Load 时，可以通过设置 `"partial_update" = "true"` 来开启此功能。
    *   **导入频率:**
        *   避免过于频繁（如毫秒级）的小批量数据导入。高频导入会产生大量的小文件，给 Compaction 带来巨大压力。
        *   建议在数据源侧或 Flink 中进行微批处理，将导入频率控制在秒级，并适当增大批次大小。

### 2.4 更新模型 (Update Key Model)

*   **描述:** 保证更新键的唯一性，读性能低于主键模型。
*   **适用场景:**
    *   低频更新的维度表。
    *   在大多数场景下，**主键模型是更新模型的更优替代方案**。

## 3. 建表最佳实践

### 3.1 字段类型与长度

*   **类型选择:**
    *   **数值类型:** 遵循"够用即可"原则。能用 `INT` 就不用 `BIGINT`，能用 `TINYINT` 就不用 `INT`。更小的类型占用更少的存储空间，计算也更快。
    *   **高精度小数:** 对金额等需要精确计算的场景，**必须**使用 `DECIMAL` 类型，避免使用 `DOUBLE` 或 `FLOAT` 导致精度损失。
    *   **字符串:** 优先使用 `VARCHAR` 并指定合理的长度。`VARCHAR(N)` 在内存中是变长的，但在磁盘上会占用更少的空间。`STRING` 类型用于存储超长文本（如文章内容），但性能略低于 `VARCHAR`。
    * **注意事项:** 避免全部使用 `VARCHAR`，如果实际数据存储为数字或者日期，则使用对应的类型。StarRocks 内部对于非 Key 列，`VARCHAR` 不会自动创建 `Zonemap` (Min/Max) 索引。

*   **长度定义:**
    *   为 `VARCHAR` 定义一个合理的、略大于业务最大可能长度的值。过长的定义（如 `VARCHAR(65535)`）虽然不直接影响存储，但会消耗更多内存，尤其是在聚合和排序计算中。

### 3.2 排序键 (Sort Key)

*   **定义方式:**
    *   在 StarRocks 3.1 及之后版本，主键模型强烈建议使用 `ORDER BY` 子句来**显式**地指定排序键。
    *   在 StarRocks 3.3 及之后版本，明细模型和聚合模型强烈建议使用 `ORDER BY` 子句来**显式**地指定排序键。

*   **选择原则:**
    1.  **高频过滤列优先:** 将最常用于 `WHERE` 条件过滤的列放在排序键的最前面。
    2.  **低基数列在前，高基数列在后:** 在过滤频率相近时，将基数较低的列（如 `city`, `province`）放在基数较高的列（如 `user_id`）前面，可以提高前缀索引的压缩率和效率。
*   **数量:** 排序键不宜过多，通常 **3-4 个**为佳。过多的排序键会增加排序开销。

### 3.3 分区键 (Partition Key)

*   **选择原则:**
    *   **时间列:** 99% 的场景下都应使用**时间列**作为分区键，如 `event_date`, `create_time`。这对于分区裁剪和数据生命周期管理至关重要。
    *   **分区粒度:** 根据数据量和查询模式决定。如果每天数据量很大，可以按天分区；如果较小，可以按周或按月分区。合理的粒度可以平衡分区数量和单个分区的大小。
*   **分区最佳实践**
    *   **优先使用表达式分区 (v3.1+):** 强烈建议使用表达式分区，特别是基于 `date_trunc` 函数对时间列进行分区。它允许您直接在分区表达式中使用函数，极大地简化了 DDL 语句，使其更易读、更不易出错。
    *   **手动管理分区:** 在生产环境中，为了对集群有更精确的控制，推荐手动管理分区（`ADD PARTITION`, `DROP PARTITION`）。

    **示例 ：使用表达式分区批量创建分区**
    ```sql
    -- 创建一个按天分区的表
    CREATE TABLE site_access (
        event_time DATETIME,
        site_id INT,
        city_code VARCHAR(10)
    )
    PARTITION BY date_trunc('day', event_time) 
    ...;
    ```

### 3.4 分桶键 (Bucket Key)

*   **选择原则:**
    *   **高基数列:** **必须**选择基数非常高的列（如 `user_id`, `order_id`, `device_id`）作为分桶键，以确保数据在所有分桶（Tablet）中均匀分布。
    *   **避免使用时间列:** **严禁**使用时间列或低基数列作为分桶键，这会导致严重的数据倾斜。
*   **数量:**
    分桶数量的设置是一门艺术，需要综合考虑分区内数据量、BE 节点数、磁盘数量和查询模式。

*   **分桶数量最佳实践:**
    *   **核心原则:** 合理设置分桶数，使得单个分桶（Tablet）的原始数据大小保持在 **1GB** 左右。这是最重要的衡量标准。
    *   **数据量小的表:**
        *   对于单个分区数据量很小（如小于 100MB）的表，可以考虑将分区粒度从“天”改为“月”，以增加单个分区的数据量。
        *   对于全表数据量都很小的表，可以考虑不分区，只分桶。
        *   对于数据量小但并发查询高（QPS > 10）的表，可以考虑设置 3 个分桶以提升并发能力。
    *   **数据倾斜处理:**
        *   如果发现数据倾斜严重（如 Tablet 大小的标准差大于 10），首先应检查分桶键是否合理，是否基数足够高。
        *   如果分桶键没有问题，但不同分区的数据量差异巨大，可以为数据量大的分区单独设置更多的分桶数。
    *   **无分区表:** 对于不分区的表，在建表时应预估未来数据增量，适当调大分桶数。
    *   **集群总 Tablet 数控制:**
        *   过多的 Tablet 会增加元数据管理的负担和调度开销。除了合理设置分桶数，还应定期清理生产环境中不再使用的测试表和备份表。
        *   生产环境**不建议**使用单副本表，应使用默认的 3 副本。请注意，副本数会使总 Tablet 数成倍增加。

### 3.5 索引 (Index)

除了排序键自带的前缀索引外，StarRocks 还支持创建额外的索引来加速查询。

*   **Bitmap 索引:**
    *   **适用场景:** 适用于多个低基数列的组合查询，并且组合查询过滤效果好。高基数列的过滤查询，并且过滤效果好。
        *   **基数建议:** 建议对于非排序键的加速都可以首先尝试bitmap索引。
        *   **工作原理:** StarRocks 会为每个不同的列值创建一个位图（Bitmap）。查询时，可以通过高效的位运算（如 AND, OR）快速筛选出符合条件的数据行。
    *   **不适用场景:**
        *   **高基数列:** 绝对不要在基数非常高的列（如 `user_id`）上创建位图索引。这会导致索引文件急剧膨胀，占用大量存储空间，并且在查询和导入时都带来巨大的性能开销。
        *   **排序键列:** 如果某列已经是排序键的一部分，它已经享受了前缀索引带来的加速效果，无需再为其创建位图索引。
    *   **成本与权衡:**
        *   **存储开销:** 位图索引会额外占用存储空间。
        *   **导入开销:** 在数据导入时，需要构建索引，这会轻微增加导入的耗时。因此，只为确实能提升查询性能的列创建索引。
    *   **创建方式:**
        ```sql
        CREATE TABLE ... (
            ...
            INDEX idx_city (city) USING BITMAP COMMENT '城市位图索引'
        )
        ...
        ```

## 4. 模型选择总结

| 模型 | 核心特点 | 典型场景 |
| :--- | :--- | :--- |
| **明细模型** | 保留原始数据，灵活分析 | 日志分析、用户行为明细、Ad-hoc 查询 |
| **聚合模型** | 数据预聚合，极致查询性能 | 固定报表、监控看板、PV/UV 统计 |
| **主键模型** | 按主键实时更新，支持 DELETE，但资源消耗较高 | CDC 数据同步、实时订单状态、用户画像 |
| **更新模型** | 整行替换，低频更新 | 维度表更新（但主键模型是更优选择） |