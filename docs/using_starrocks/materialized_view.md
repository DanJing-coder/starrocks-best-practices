# StarRocks 最佳实践之物化视图

## 1. 物化视图介绍

### 什么是物化视图？

物化视图 (Materialized View) 是一种特殊的物理表，它存储了预先计算好的查询结果。与普通视图不同，物化视图是物理存在的，它能够极大地提高查询性能，特别是对于复杂的聚合查询和 Join 查询。

### StarRocks 物化视图的特点

*   **丰富的聚合能力**：支持各种聚合函数，如 SUM, COUNT, AVG, MIN, MAX 等，以及复杂的 Join 和窗口函数。
*   **多种刷新策略**：
    *   **异步 (ASYNC)**：按需或周期性地刷新物化视图。
    *   **同步 (SYNC)**：在基表数据写入时同步更新物化视图，保证数据强一致性。
    *   **手动 (MANUAL)**：完全由用户手动控制刷新时机。
*   **查询透明改写**：StarRocks 的查询优化器能够自动、透明地将查询重写，以利用最优的物化视图来加速查询，无需用户修改任何查询语句。
*   **分区刷新**：支持对分区级别的物化视图进行刷新，大大提高了刷新效率和灵活性。

---

## 2. 异步物化视图

异步物化视图是 StarRocks 中功能最强大、使用最灵活的物化视图类型。

### 刷新机制

异步物化视图的刷新可以由系统周期性地触发，也可以由用户手动触发。刷新操作会重新计算定义物化视图的 SQL 语句，并将结果原子地覆盖旧数据。

```sql
-- 手动刷新整个物化视图
REFRESH MATERIALIZED VIEW mv_name;

-- 手动刷新指定分区
REFRESH MATERIALIZED VIEW mv_name PARTITION START ('2023-01-01') END ('2023-01-02');
```

### 分区与数据一致性

StarRocks 的异步物化视图能够保证与基表的分区级别数据一致性。它通过映射基表的分区来实现自身的分区，当基表增加或删除分区时，物化视图也会相应地进行处理。

### 创建异步物化视图

```sql
CREATE MATERIALIZED VIEW mv_name
-- 分区键建议与基表保持一致
PARTITION BY (k1)
-- 合理设置分桶键以避免数据倾斜
DISTRIBUTED BY HASH(k2)
-- 设置刷新策略
REFRESH ASYNC START('2023-01-01 00:00:00') EVERY(INTERVAL 1 DAY)
-- 设置副本数等属性
PROPERTIES (
    "replication_num" = "1"
)
-- 定义物化视图的查询语句
AS SELECT k1, k2, SUM(v1) as total_sum
FROM base_table
GROUP BY k1, k2;
```

---

## 3. 同步物化视图

同步物化视图在基表数据写入时会同步更新，保证了物化视图与基表之间的数据强一致性。

### 特点

*   **强一致性**：数据总是与基表保持同步。
*   **写入开销**：会增加数据写入的延迟和资源消耗。

### 限制

*   只支持单个基表。
*   支持的聚合函数有限 (SUM, MIN, MAX, COUNT)。
*   查询定义中不能包含 Join, Group By, Order By, Limit 等复杂操作。

---

## 4. 手动挡物化视图

手动挡物化视图的刷新完全由用户通过 `REFRESH MATERIALIZED VIEW` 命令来触发。它适用于对刷新时机有精确控制需求的场景，例如在 T+1 的数据处理流程中。

---

## 5. 物化视图的查询改写

查询改写是物化视图发挥作用的核心机制。StarRocks 的优化器会智能地判断一个查询是否能够被某个物化视图所满足，如果可以，就会将查询重写，直接从物化视图中读取数据，从而实现加速。

### 如何确认查询是否被改写

使用 `EXPLAIN` 命令可以查看查询的执行计划。如果在计划中看到了物化视图的名称 (例如 `scan: MV(mv_name)`)，则说明查询已经被成功改写。

```sql
EXPLAIN COSTS SELECT k1, SUM(v1) FROM base_table GROUP BY k1;
```

### 查询改写示例

PDF 中包含了多个详细的查询改写示例，涵盖了单表聚合、Join、Union、嵌套以及分区裁剪等多种场景，并给出了详细的 `EXPLAIN` 分析，展示了优化器如何利用物化视图来优化查询。

---

## 6. 物化视图的管理

| 操作 | 命令 |
| :--- | :--- |
| 查看所有物化视图 | `SHOW MATERIALIZED VIEWS;` |
| 查看创建语句 | `SHOW CREATE MATERIALIZED VIEW mv_name;` |
| 修改刷新策略 | `ALTER MATERIALIZED VIEW mv_name REFRESH ...;` |
| 重命名 | `ALTER MATERIALIZED VIEW mv_name RENAME new_mv_name;` |
| 删除物化视图 | `DROP MATERIALIZED VIEW mv_name;` |
| 查看刷新任务 | `SHOW REFRESH [FROM db_name];` |
| 取消刷新任务 | `CANCEL REFRESH MATERIALIZED VIEW mv_name;` |

---

## 7. 最佳实践

*   **按需创建**：只为频繁使用且性能瓶颈明显的查询创建物化视图。
*   **避免数据爆炸**：精心设计物化视图的维度和指标，避免物化视图自身的数据量过大。
*   **分区和分桶**：物化视图的分区和分桶策略应与基表对齐，以获得最佳的刷新和查询性能。
*   **利用 `EXPLAIN`**：在创建物化视图后，务必使用 `EXPLAIN` 来验证目标查询是否能够被成功改写。
*   **监控与维护**：定期监控物化视图的刷新状态和数据大小，及时进行调整和优化。

---

## 8. 常见问答 (Q&A)

**Q1: 物化视图是否支持所有 SQL 函数？**

A: 不完全支持。虽然 StarRocks 的物化视图支持大量的函数，但仍有一些特殊的函数（如部分窗口函数、UDF等）可能不支持。在创建物化视图时，如果使用了不支持的函数，系统会报错。建议在设计物化视图前，先查阅官方文档确认相关函数的支持情况。

**Q2: 如何排查查询没有被物化视图改写的问题？**

A: 可以从以下几个方面进行排查：
1.  **确认物化视图是否可用**：通过 `SHOW MATERIALIZED VIEWS` 查看物化视图的 `is_active` 状态是否为 `true`。只有激活的物化视图才能用于查询改写。
2.  **确认查询逻辑是否匹配**：确保查询语句中的表、列、函数、条件等逻辑能够完全被物化视图的定义所覆盖。
3.  **使用 `EXPLAIN` 分析**：这是最直接的方式。`EXPLAIN` 的输出会明确地告诉你查询是否命中了物化视图，以及选择了哪个物化视图。
4.  **查看优化器日志**：在某些复杂场景下，可以查看 FE 的日志来获取更详细的优化器决策信息。

**Q3: 基表数据被删除后，物化视图如何处理？**

A: StarRocks 的数据删除是逻辑删除。对于异步物化视图，在下一次刷新时，会重新计算查询结果，此时被删除的数据将不再包含在物化视图中。对于同步物化视图，基表的删除操作会同步地反映到物化视图上。

**Q4: 构建物化视图有哪些建议？**

A: 
*   **按需构建**：核心原则是“按需构建”，不要盲目地创建大量物化视图。优先为最频繁、最耗时的查询构建视图。
*   **权衡利弊**：物化视图是空间换时间的典型应用。在享受查询加速的同时，也要考虑到它带来的存储成本和维护成本。
*   **从简到繁**：可以先从简单的单表聚合视图开始，逐步尝试更复杂的 Join 视图。
*   **充分测试**：创建物化视图后，一定要进行充分的测试，确保它能够被目标查询正确、高效地利用。